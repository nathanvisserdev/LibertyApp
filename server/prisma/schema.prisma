generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum RequestType {
  ACQUAINTANCE
  STRANGER
  FOLLOW
}

enum RequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELED
}

enum ConnectionType {
  ACQUAINTANCE
  STRANGER
  IS_FOLLOWING
}

enum PostVisibility {
  PUBLIC        // shows in Public Square if not in PRIVATE/PERSONAL group
  CONNECTIONS   // author's connections only
  GROUP         // governed by group membership
}

enum MediaOrientation {
  LANDSCAPE
  PORTRAIT
}

enum GroupType {
  AUTOCRATIC
  ROUND_TABLE
}

enum GroupPrivacy {
  PUBLIC     // General Assembly
  PRIVATE    // Assembly Room
  PERSONAL   // Social Circle (owner = admin)
}

enum GroupJoinPolicy {
  CHAIR          // only group admin approves (The chair)
  CHAIR_PEOPLE    // chairs (if RoundTable exists) and the chair approves
}

enum RoundTableRole {
  CHAIR
  VICE_CHAIR
  CHAIRMAN
  CHAIRWOMAN
  CHAIRPERSON
}

enum ElectionCycle {
  THREE_MONTHS
  SIX_MONTHS
  ONE_YEAR
  TWO_YEARS
  FOUR_YEARS
}

enum UnilateralAction {
  CHAIR_RELINQUISHED
  SETTINGS_CHANGED
}

enum RepresentativeAction {
  REPRESENTATIVE_ABSENT
  REPRESENTATIVE_RETURNED
}

enum ConsensusAction {
  BAN_ENACTED
  BAN_REVOKED
  CHAIR_ELECTED
  VICE_CHAIR_ELECTED
  ELECTIONS_ENABLED
  ELECTION_CYCLE_CHANGED
}

enum MotionType {
  ELECTION_ENABLE
  ELECTION_CYCLE_CHANGE
  CHAIR_REELECTION_DUE_TO_ABSENCE
  REMOVE_REPRESENTATIVE
  GENERAL
}

enum VoteChoice {
  YES
  NO
  ABSTAIN
}

enum SubNetRole {
  OWNER
  MANAGER
  CONTRIBUTOR
  VIEWER
}

enum SubNetVisibility {
  PRIVATE
  ACQUAINTANCES
  CONNECTIONS
  PUBLIC
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  firstName     String?
  lastName      String?
  username      String?   @unique
  dateOfBirth   DateTime?
  gender        Gender
  phoneNumber   String?
  zipCode       String?
  profilePhoto  String
  about         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  isPrivate     Boolean
  isHidden      Boolean   @default(false)
  isPaid        Boolean   @default(false)
  isBanned      Boolean   @default(false)

  posts         Post[]
  groups        GroupMember[]

  userConnections   UserConnection[] @relation("UserConnection_user")
  outgoingRequests  ConnectionRequest[] @relation("req_outgoing")
  incomingRequests  ConnectionRequest[] @relation("req_incoming")
  following         Connection[] @relation("conn_outgoing")
  followers         Connection[] @relation("conn_incoming")
  blocksInitiated   Block[] @relation("blocks_blocker")
  blocksReceived    Block[] @relation("blocks_blocked")

  adminGroups       Group[] @relation("GroupAdmin")
  sentInvites       GroupInvite[] @relation("Invite_Inviter")
  receivedInvites   GroupInvite[] @relation("Invite_Invitee")
  decidedInvites    GroupInvite[] @relation("Invite_Decider")
  vouchedInvites    GroupInvite[] @relation("Invite_Voucher")

  joinRequests         JoinGroup[] @relation("Join_Requester")
  decidedJoinRequests  JoinGroup[] @relation("Join_Decider")
  preferredReviewerFor JoinGroup[] @relation("Join_PreferredReviewer")
  vouchedJoinRequests  JoinGroup[] @relation("Join_Voucher")

  roundTableAdmin        RoundTable[] @relation("RoundTable_Admin")
  roundTableViceChair    RoundTable[] @relation("RoundTable_Vice")
  roundTableMemberships  RoundTableMember[]
  roundTableMotionsCreated RoundTableMotion[]
  roundTableLogs         RoundTableLog[]
  roundTableContinuity   RoundTableContinuity[]

  deviceTokens DeviceToken[] @relation("UserDeviceTokens")

  pendingRequestCount Int @default(0)

  // Sub-Networks
  subnets               SubNet[] @relation("OwnedSubNets")
  subNetMemberships     SubNetMember[]

  defaultSubNetId       String?
  defaultSubNet         SubNet? @relation("DefaultSubNet", fields: [defaultSubNetId], references: [id], onDelete: SetNull)

  @@index([isPaid])
  @@index([defaultSubNetId])
}

model DeviceToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  platform  String   // "ios" or "android"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation("UserDeviceTokens", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Group {
  id          String    @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime  @default(now())

  groupType   GroupType        @default(AUTOCRATIC)
  groupPrivacy GroupPrivacy    @default(PRIVATE)

  isHidden    Boolean      @default(false)
  membershipHidden Boolean @default(false)

  adminId     String
  admin       User        @relation("GroupAdmin", fields: [adminId], references: [id])
  groupJoinPolicy GroupJoinPolicy @default(CHAIR)
  vouchingEnabled Boolean         @default(false)

  // foreign key (optional 1:1 RoundTable)
  roundTable  RoundTable?
  posts       Post[]
  members     GroupMember[]
  invites     GroupInvite[]
  joinRequests JoinGroup[]

  roundTableMembers    RoundTableMember[]
  roundTableMotions    RoundTableMotion[]
  roundTableLogs       RoundTableLog[]
  roundTableContinuity RoundTableContinuity[]

  @@index([groupType])
  @@index([groupPrivacy])
  @@index([adminId])
  @@unique([adminId, name])
}

model GroupInvite {
  id          String        @id @default(cuid())
  groupId     String
  inviteeId   String
  inviterId   String
  status      RequestStatus @default(PENDING) // PENDING → ACCEPTED | DECLINED | CANCELED
  createdAt   DateTime      @default(now())
  decidedAt   DateTime?
  decidedById String?

  // Optional vouching
  voucherId   String?
  vouchStatus RequestStatus? @default(ACCEPTED)
  vouchNote   String?

  group       Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  invitee     User  @relation("Invite_Invitee",  fields: [inviteeId],   references: [id], onDelete: Cascade)
  inviter     User  @relation("Invite_Inviter",  fields: [inviterId],   references: [id])
  decidedBy   User? @relation("Invite_Decider",  fields: [decidedById], references: [id])
  voucher     User? @relation("Invite_Voucher",  fields: [voucherId],   references: [id])

  @@index([groupId, status, createdAt])
  @@index([inviteeId, status])
  @@index([inviterId])
  @@index([voucherId, vouchStatus])
  @@unique([groupId, inviteeId])
}

model JoinGroup {
  id                  String        @id @default(cuid())
  groupId             String
  requesterId         String
  status              RequestStatus @default(PENDING) // PENDING → ACCEPTED | DECLINED | CANCELED
  createdAt           DateTime      @default(now())
  decidedAt           DateTime?
  decidedById         String?

  // Routing + vouching
  preferredReviewerId String?
  voucherId           String?
  vouchStatus         RequestStatus?
  vouchNote           String?
  relationshipType    ConnectionType?

  group              Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  requester          User  @relation("Join_Requester",          fields: [requesterId],         references: [id], onDelete: Cascade)
  decidedBy          User? @relation("Join_Decider",            fields: [decidedById],         references: [id])
  preferredReviewer  User? @relation("Join_PreferredReviewer",  fields: [preferredReviewerId], references: [id])
  voucher            User? @relation("Join_Voucher",            fields: [voucherId],           references: [id])

  @@index([groupId, status, createdAt])
  @@index([requesterId, status])
  @@index([preferredReviewerId])
  @@index([voucherId, vouchStatus])
}

model RoundTable {
  // 1:1 to Groups; not all groups have one
  groupId                String   @id
  group                  Group   @relation(fields: [groupId], references: [id])

  // Round table roles
  adminId                String
  admin                  User    @relation("RoundTable_Admin", fields: [adminId], references: [id])
  viceChairId            String?
  viceChair              User?   @relation("RoundTable_Vice", fields: [viceChairId], references: [id])

  // Round table type
  roundTableType         GroupType        @default(AUTOCRATIC) // AUTOCRATIC vs ROUND_TABLE

  // settings
  electionsEnabled       Boolean          @default(false)      // app-enforced monotonic
  electionCycle         ElectionCycle?
  absentDaysThreshold    Int              @default(5)
  inactiveAdminVoteDays  Int              @default(30)

  // relations
  roundTableMembers      RoundTableMember[]
  continuity             RoundTableContinuity[]
  roundTableLogs         RoundTableLog[]
  motions                RoundTableMotion[]

  @@index([adminId])
  @@index([viceChairId])
  @@index([roundTableType])
}

model RoundTableMember {
  id           String        @id @default(cuid())
  groupId      String
  userId       String
  role         RoundTableRole @default(CHAIRPERSON) // neutral default; enforce one CHAIR and one VICE_CHAIR in app or raw SQL
  isModerator  Boolean       @default(false)
  isExpelled   Boolean       @default(false)
  joinedAt     DateTime      @default(now())
  absentUntil  DateTime?

  // Planned leave (max 1y)
  plannedLeaveFrom  DateTime?
  plannedLeaveUntil DateTime?
  plannedLeaveNote  String?

  roundTable RoundTable @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId],  references: [id], onDelete: Cascade)
  votes RoundTableVote[]

  @@unique([groupId, userId])
  @@index([groupId, role])
}

model RoundTableMotion {
  id          String      @id @default(cuid())
  groupId     String
  type        MotionType
  title       String
  details     String?
  createdById String?             // null if system-triggered
  showPublic  Boolean     @default(true)
  createdAt   DateTime    @default(now())
  closesAt    DateTime?
  closedAt    DateTime?
  passed      Boolean?

  roundTable RoundTable @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
  group   Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  creator User? @relation(fields: [createdById], references: [id])
  votes   RoundTableVote[]

  @@index([groupId, type, createdAt])
}

model RoundTableVote {
  id        String   @id @default(cuid())
  motionId  String
  voterId   String
  choice    VoteChoice
  createdAt DateTime  @default(now())

  motion RoundTableMotion @relation(fields: [motionId], references: [id], onDelete: Cascade)
  voter  RoundTableMember @relation(fields: [voterId], references: [id])

  @@unique([motionId, voterId])
  @@index([voterId])
}

model RoundTableLog {
  id        String            @id @default(cuid())
  groupId   String
  actorId   String?           // who performed or proposed; null for system
  unilateral UnilateralAction?
  consensus  ConsensusAction?
  targetId  String?           // optional subject (e.g., affected user)
  details   String?           // minimal reason code / hash; avoid PII
  createdAt DateTime          @default(now())

  roundTable RoundTable @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  actor User? @relation(fields: [actorId], references: [id])

  @@index([groupId, createdAt])
  @@index([groupId, unilateral])
  @@index([groupId, consensus])
}

model RoundTableContinuity {
  id        String   @id @default(cuid())
  groupId   String
  userId    String
  rank      Int      // 1 = first in line after VICE; auto-maintained from 4th admin onward
  createdAt DateTime @default(now())

  roundTable RoundTable @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId],  references: [id], onDelete: Cascade)

  @@unique([groupId, rank])
  @@unique([groupId, userId])
  @@index([groupId])
}


model GroupMember {
  membershipId String   @id @default(cuid())
  userId       String
  groupId      String
  joinedAt     DateTime @default(now())
  isBanned     Boolean @default(false)

  user  User  @relation(fields: [userId], references: [id])
  group Group @relation(fields: [groupId], references: [id])

  @@unique([userId, groupId])
}

model Post {
  id            String   @id @default(cuid())
  content       String?
  media         String?
  orientation   MediaOrientation?
  visibility    PostVisibility @default(PUBLIC)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  userId        String
  groupId       String?
  subNetId      String?     // target audience within user's network

  user          User       @relation(fields: [userId], references: [id])
  group         Group?     @relation(fields: [groupId], references: [id])
  subNet        SubNet?    @relation(fields: [subNetId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt, id])         // profile feed keyset
  @@index([groupId, createdAt, id])        // group feed
  @@index([subNetId, createdAt, id])       // subnet feed
  @@index([visibility])
}

model ConnectionRequest {
  id          String      @id @default(cuid())
  requesterId String
  requestedId String
  type        RequestType
  status      RequestStatus  @default(PENDING)
  createdAt   DateTime       @default(now())
  decidedAt   DateTime?

  requester User @relation("req_outgoing", fields: [requesterId], references: [id])
  requested User @relation("req_incoming", fields: [requestedId], references: [id])

  @@unique([requesterId, requestedId])
  @@index([requesterId, requestedId, type, status])
}

model Connection {
  id          String   @id @default(cuid())

  // MUTUAL: requesterId=min(userA,userB), requestedId=max(userA,userB)
  // DIRECTED: requesterId=followerId, requestedId=userId
  requesterId String
  requestedId String

  type        ConnectionType
  since       DateTime @default(now())

  requester   User @relation("conn_outgoing", fields: [requesterId], references: [id])
  requested   User @relation("conn_incoming", fields: [requestedId], references: [id])

  adjacencies UserConnection[] @relation("UserConnection_connection")
  subNetMembers SubNetMember[]

  @@unique([requesterId, requestedId, type])
  @@index([requesterId, requestedId, type])
  @@index([requestedId, requesterId, type])
}

model UserConnection {
  userId        String
  otherUserId   String
  connectionId  String
  type          ConnectionType
  createdAt     DateTime       @default(now())

  user          User       @relation("UserConnection_user", fields: [userId], references: [id], onDelete: Cascade)
  connection    Connection @relation("UserConnection_connection", fields: [connectionId], references: [id], onDelete: Cascade)

  @@id([userId, otherUserId, type])
  @@index([userId, type, createdAt])
  @@index([otherUserId, type])  // For fast follower lookups
}

model SubNet {
  id          String   @id @default(cuid())
  ownerId     String
  owner       User    @relation("OwnedSubNets", fields: [ownerId], references: [id], onDelete: Cascade)

  name        String
  slug        String
  description String?

  visibility  SubNetVisibility @default(PRIVATE)
  isDefault   Boolean  @default(false)
  ordering    Int      @default(0)

  // hierarchy (optional layering)
  parentId    String?
  parent      SubNet?  @relation("SubNetHierarchy", fields: [parentId], references: [id])
  children    SubNet[] @relation("SubNetHierarchy")

  // denormalized counters
  memberCount Int      @default(0)
  postCount   Int      @default(0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members     SubNetMember[]
  posts       Post[]
  defaultFor  User[]  @relation("DefaultSubNet")

  @@unique([ownerId, slug])                // global-per-owner slug uniqueness
  @@index([ownerId])
  @@index([ownerId, createdAt, id])        // keyset pagination for owner's subnets
  @@index([ownerId, parentId, ordering])
  @@index([parentId])
}

model SubNetMember {
  id            String         @id @default(cuid())
  subNetId      String
  userId        String          // fast read key; must be a valid connection to ownerId (enforce in service)
  connectionId  String          // integrity FK to Connection.id

  role          SubNetRole  @default(VIEWER) // OWNER implicit via SubNet.ownerId
  createdAt     DateTime        @default(now())

  subNet        SubNet         @relation(fields: [subNetId], references: [id], onDelete: Cascade)
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  connection    Connection     @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@unique([subNetId, userId])
  @@index([userId, subNetId])
  @@index([subNetId, role])
  @@index([connectionId])
}

// Directed block: (blockerId -> blockedId)
model Block {
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker User @relation("blocks_blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("blocks_blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@id([blockerId, blockedId])
  @@index([blockedId])
}
